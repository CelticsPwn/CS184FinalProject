<style>
body {
    margin: 0px;
    overflow: hidden;
}
</style>
<body>

<script src="libraries/three.min.js"></script>

<script id="vertexShader" type="x-shader/x-fragment">
    varying vec2 vUv;

    void main()
    {
        vUv = uv;
        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
        gl_Position = projectionMatrix * mvPosition;
    }
</script>
<script id="black_hole" type="x-shader/x-fragment">
uniform vec2 u_resolution;
uniform vec3 u_mouse;
uniform sampler2D u_currentTexture;
uniform sampler2D u_texture;
uniform int u_frameCount;
uniform float u_mouseSize;
uniform int u_paused;
varying vec2 vUv;
uniform float u_time;

#define NUM_USER_LENSES 10

float M = 0.1;

float rand(float x) {
    return fract(sin(x * 12.9898) * 43758.5453);
}
vec2 rand2(float x) {
    return vec2(fract(sin(x * 12.9898) * 43758.5453),
                fract(sin(x * 78.2330) * 43758.5453));
}

vec3 rotate(vec3 a)
{
    vec3 b = a;
    float sinT = sin(u_time);
    float cosT = cos(u_time);
    b.x = (cosT*a.x)-(sinT*a.z);
    b.z = (sinT*a.x)+(cosT*a.z);
    return b;
}

float v(float xrel, float yrel) {
    // Takes input relative to current pixel and returns pixel value.
    vec2 xy;
    xy.x = mod(gl_FragCoord.x + xrel, u_resolution.x);
    xy.y = mod(gl_FragCoord.y + yrel, u_resolution.y);

    return texture2D(u_currentTexture, xy/u_resolution).a;
}

void main() {
    // Compute convergence and shear effects of continuous matter
    float     u_kappa_c = .2;
    float     u_gamma_c = .3;
    int       u_lens_count = 1;
    float     u_lens_mass = .1;
    float kc = u_kappa_c;
    float gc = u_gamma_c;
    vec2 scaling = vec2(1.0-kc-gc, 1.0-kc+gc);
    vec2 inv_scaling = 1. / scaling;

    // Compute deflection and shear due to point lenses
    vec2 deflection = vec2(0.0, 0.0);
    vec2 shear      = vec2(0.0, 0.0);
    int n = u_lens_count;
    const int max_lens_count = 256;

    vec2 position = vUv;
    position.y *= -1.; // HACK TESTING

    for( int i=0; i<max_lens_count; ++i ) {
        if( i == n ) {
        break;
        }
        // Generate random lens positions
        vec2 lens = rand2(float(i) * (1. / float(max_lens_count))) * 2. - 1.;
        lens *= 3.;
        if( i < NUM_USER_LENSES ) {
        // This is a user-movable lens
            lens = u_mouse.xy;
        }
        // Compute the deflection
        vec2 r = lens - position * inv_scaling;
        float r2 = dot(r, r);
        // Note: We normalize by n to give fixed total mass
        float mass = u_lens_mass * (1. / float(n));
        mass *= 0.5; // HACK TESTING
        float eps = 0.;//1e-2;
        r2 += eps * eps;
        deflection += mass * r / r2;
        // Compute the shear
        float m_on_r4 = mass / (r2 * r2);
        shear += vec2((r.y * r.y - r.x * r.x) * m_on_r4,
                    2.0 * r.x * r.y * m_on_r4);
    }

    vec2 g = shear;
    float k = 1.0 - kc;
    g.x += gc;
    float magnification = 0.25 / (k * k - dot(g, g));

    // Apply the deflection to the texture coordinates
    vec2 texcoord = position + deflection;
    texcoord = 0.5 * (texcoord + 1.); // [-1:1] -> [0:1]
    vec4 color = texture2D(u_texture, texcoord);
    float m = 100. * abs(magnification);
    color.w = m;

    gl_FragColor = color;
    //gl_FragColor = texture2D(u_texture, vUv);
}
</script>

<script src="app.js"></script>

</body>